---
title: "roar-with-purrr"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "css/ohsu.css", "css/ohsu-fonts.css"]
    seal: false
    nature:
      countIncrementalSlides: false
      highlightLines: true
      highlightStyle: github
---

class: inverse, left, bottom
background-image: url(figs/lion.jpg)
background-size: cover

# Make your R roar by purrring
### Gavin Fay   
<br> __2020-04-07: UMassD Quantfish woRkshop__
<br>`r icon::fa("link")` [github.com/gavinfay/roar-with-purrr](https://github.com/gavinfay/roar-with-purrr)
<br> `r icon::fa("envelope")` [gfay@umassd.edu](gfay@umassd.edu)  `r icon::fa("twitter")` [gavin_fay](https://twitter.com/gavin_fay)

<!-- [default, metropolis, metropolis-fonts] -->
<!--    highlightStyle: atelier-lakeside-light -->


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(prompt = FALSE)
options(htmltools.dir.version = FALSE)
library(tidymodels)
library(tidyverse)
#library(infer)
#devtools::install_github("gadenbuie/countdown")
library(countdown)
```
---

background-image: url(figs/logo.png)
background-position: 95% 5%
background-size: 10%

## Make your R roar with `purrr`

Google Doc containing links to today's resources:  
[bit.ly/roar-with-purrr]("bit.ly/roar-with-purrr")

Add your name to attendance.  

Add notes/tips to googledoc to create shared learning resource.  

Use your own computer or RStudio Cloud machine  

These slides:
[gavinfay.github.io/roar-with-purrr/purrr-slides]("gavinfay.github.io/roar-with-purrr/purrr-slides")

My .Rmd updated live at:  
[https://github.com/gavinfay/roar-with-purrr]("https://github.com/gavinfay/roar-with-purrr")

__Acknowledgements:__  
[Dan Ovando]("https://twitter.com/DanOvand0"), 
[Maia Kapur]("https://twitter.com/KapurMaia"), 
[Mine Çetinkaya-Rundel]("https://twitter.com/minebocek"), 
[Alison Hill]("https://twitter.com/apreshill")

---

## Reducing code duplication

- Easier to see the intent of your code, eyes are drawn to what’s different, not what stays the same.  

- Easier to respond to changes, only need to make changes in one place, rather than every place you copied-and-pasted.  

- Likely to have fewer bugs because each line of code is used in more places.  

How? Iteration (today) & Functions  

---

## Iteration

When you need to do the same thing to multiple inputs: repeating the same operation on different columns, or on different datasets.  

Two main paradigms:  
1. imperative programming  
2. functional programming  


---

## Problem 1

We have data from several years of crab surveys.  

The data for each year is contained in separate ".csv" files.  

We would like to read these data into R, and combine them into a single data frame so we can inspect and plot them.  

---

## Problem 2  

We have data on Steller sea lion pup counts over time at a bunch of rookeries in Alaska.  
The number of data points for each rookery is not the same.  

We want to investigate the annual trend in counts for each rookery.  
[i.e. fit a regression of log(counts) on time for each rookery]
We want to plot the slopes of the regressions using a histogram.  
We want to obtain confidence intervals of the slope estimates using bootstrapping.  

---

## Problem 3  

We are interested in creating a standardized time series of CPUE for a fishery, by 'removing' the effect of variables that affect catch rates such that we have an index of abundance.  
We have many possible variables.  
We would like to compare models that use different combinations of these variables.  

---

## Problem 4

Status for endangered species are often based on a risk evaluation of population projections.  
We want to project population dynamics forward in time given uncertainty in future dynamics.  
We want to do this lots of times to quantify the risk of extinction.  


---

## Familiar approaches?

--

### `for` / `while` loops ...
### `apply` functions (`apply()`, `tapply()`, `sapply()`, `lapply()`)  
### `aggregate()` ...
### `group_by() %>% summarize()` in `dplyr` ...

--

### `purrr` package is tidyverse solution.  

---

## Pivot tables & loops 


```{r comment='',collapse=TRUE,eval=FALSE}
for (i in unique(iris$Species)) {
  meanSepalLength <-
      mean(data[iris$Species==i,]$Sepal.Length)
  cat(i, meanSepalLength, "\n")
}
```

```{r eval=FALSE}
with(iris,tapply(Sepal.Length, Species, mean))   
```


```{r eval=FALSE}
aggregate(iris$Sepal.Length, by=list(iris$Species), mean)
```

```{r eval=FALSE}
iris %>% 
  group_by(Species) %>% 
  summarize(mean = mean(Sepal.Length))
```

---

## Common way to use loops  

```{r comment='',collapse=TRUE,eval=FALSE}
#define the elements to loop over
species <- sort(unique(iris$Species))

#define how many times to do the loop
nspecies <- length(species)

#create a place to store results
mean.lengths <- vector(length=nspecies)

#get loopy
for (i in 1:nspecies) {
  species.data <- iris[iris$Species==species[i], ]
  mean.lengths[i] <- mean(species.data$Sepal.Length) #<< 
  print(mean.lengths[i])
  cat("Running species ", i,"\n")
}
```

A lot of this code is book-keeping rather than the thing we want to do.  

---

background-image: url(figs/logo.png)
background-position: 0% 100%
background-size: 10%

## `purrr`

`for` loops are simple, but they require lots of code that is mostly book-keeping.  

Attention is then on this rather than the action the code is doing.  

Functional programming abstracts the book-keeping of the loop to keep attention on the code that matters.  

Series of `apply` functions in base R. (`apply`, `tapply`, `sapply`, `lapply`)  
These all have slight differences about how they are used.  

`purrr` package is the tidyverse solution to the apply functions.  

---

class: center, middle

![](figs/giraffic_park.gif)

---

background-image: url(figs/worldcat.jpg)
background-position: 50% 100%
background-size: 30%

## Basics of `purrr`

The `map` function is the workhorse of `purrr`.  
e.g. 
.pull-left[
```{r}
shades <- colors()[1:5]  
for (i in seq_along(shades)) { 
  print(shades[i])  
}
```
]

--

.pull-right[
```{r}
a <-  map(shades, print)  #<<
```
]

---

## `map`

Basic syntax:

```{r eval=FALSE}
map("Lists to apply function to",  #<<
    "Function to apply across lists",  #<<
    "Additional parameters")  #<<
```

`map` by default returns a list. However we can specify the type of output:  

`map_dbl` returns real numbers  
`map_lgl` returns logicals  
`map_chr` returns characters  
`map_int` returns integers  
`map_df`  returns a dataframe    

![](figs/map.png)

[cheatsheat: github.com/rstudio/cheatsheets/blob/master/purrr.pdf](https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf)


---

## Shortcuts

```{r eval = FALSE}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df)) #<<
```

The syntax for creating an anonymous function in R is quite verbose so purrr provides a convenient shortcut: a one-sided formula.  

```{r}
models <- mtcars %>% 
  split(.$cyl) %>%  
  map(~lm(mpg ~ wt, data = .))  #<<
  #The 1st ~ is shorthand for a function
  #The '.' shows where the stuff passed to map gets used.
```  

---

## Shortcuts 2

Extracting summary statistics

```{r eval=FALSE}
models %>%
  map(summary) %>% 
  map_dbl(pluck, "r.squared")
```

```{r eval=FALSE}
models %>%
  map(summary) %>% #run 'summary() for each model
  map_dbl(~.$r.squared) # find the R-squared
```

Extracting named components is a common operation, so can use a string instead.

```{r eval = FALSE, warning = FALSE}
models %>%
  map(summary) %>% #run 'summary() for each model
  map_dbl("r.squared") #find the R-squared 
```

---

## Exercise 1

Write code that uses one of the map functions to:  

a. Compute the mean of every column in `mtcars`.  
b. Determine the type of each column in `nycflights13::flights`.  
c. Compute the number of unique values in each column of `iris`.  

```{r echo = FALSE}
countdown(minutes = 5)
```

---

## Extending to multiple input lists

`map2` allows you to map over two sets of inputs.  

```{r eval=FALSE}
map2(list1, list2, ~function(.x,.y), ...)
```

e.g. generate 3 sets of 5 normal random variables, with the means & standard deviations different in each set.  
```{r}
mu <- list(5, 10, -3)
sigma <- list(1, 5, 10)
map2(mu, sigma, rnorm, n = 5) %>% str()
```

![](figs/map2.png)

---

##  More than 2 inputs, use `pmap`

e.g. same problem as previous, but now n varies in each set.  

```{r}
n <- list(1, 3, 5)
mu <- list(5, 10, -3)
sigma <- list(1, 5, 10)

args1 <- list(mean = mu, sd = sigma, n = n)
args1 %>%
  pmap(rnorm) %>%  #<<
  str()
```

Safest to use named arguments with `pmap`, as it will do positional matching if not.  

![](figs/pmap.png)

---

## Debugging using `safely`

Handling errors can be tricky to diagnose with map.  
It's not as obvious when things break.  

Can use `safely()`. e.g.  

```{r}
safe_log <- safely(log, otherwise = NA_real_) #<<
#safe_log return a NA if log() returns error, plus error msg.  
list("a", 10, 100) %>%
  map(safe_log) %>%  #<<
  transpose() %>%
  simplify_all()
```

---

## `accumulate()`

We sometimes like to use the output of one iteration as input to the next.  

e.g. model population dynamics over time, iterated function is annual population update.  

$N_{t+1} = \lambda N_{t} - h_{t}$

Can achieve this using `accumulate()`.  

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("figs/accumulate.png")
```

---

## `accumulate()`

We sometimes like to use the output of one iteration as input to the next.  

e.g. model population dynamics over time, iterated function is annual population update.  

$N_{t+1} = \lambda N_{t} - h_{t}$

Can achieve this using `accumulate()`.  

```{r warning = FALSE}
pop_update <- function(N, h=0, lambda = 1.05) lambda*N - h
h <- rep(10,10)
initN <- 100
accumulate(h, pop_update, .init = initN, lambda = 1.05)
```

```{r, warning = FALSE}
accumulate(letters[1:10], paste, sep = "+")
```

---

## Crab example, switch to RStudio

We have data from several years of crab surveys.  

The data for each year is contained in separate ".csv" files.  

We would like to read these data into R, and combine them into a single data frame so we can inspect and plot them.  

---

```{r warning = FALSE, comment=FALSE, message=FALSE}
files <- dir(path = "data/crabs", 
             pattern = "*.csv", 
             full.names = TRUE)
files
```

---

```{r warning = FALSE, comment=FALSE, message=FALSE}
files <- dir(path = "data/crabs", 
             pattern = "*.csv", 
             full.names = TRUE)
#files
crab_data <- map_df(files, read_csv) %>% 
  group_by(year, site) %>%
  I()
crab_data
```

---

.pull-left[
```{r crabs, warning = FALSE, comment=FALSE, message=FALSE, fig.show = 'hide'}
files <- dir(path = "data/crabs", 
             pattern = "*.csv", 
             full.names = TRUE)
#files
crab_data <- map_df(files, read_csv) %>% 
  group_by(year, site) %>%
  I()
#crab_data
crab_plot <- ggplot(crab_data) +
  aes(x = carcinus, 
      y = cancer, 
      group = site) +
  geom_point() +
  facet_wrap(~site) +
  theme_minimal() +
  NULL
crab_plot
```
]

--

.pull-right[
```{r ref.label= 'crabs', echo = FALSE, retina = 3, message= FALSE}
```
]



---

## Problem 2  

We have data on Steller sea lion pup counts over time at a bunch of rookeries in Alaska.  

```{r out.width="60%", retina = 3, echo= FALSE}
knitr::include_graphics("figs/Slide5.png")
```

The number of data points for each rookery is not the same.  

We want to investigate the annual trend in counts for each rookery.  
We want to plot the slopes of the regressions using a histogram.  
We want to obtain confidence intervals of the slope estimates using bootstrapping.  


<!-- --- -->

<!-- ```{r} -->

<!-- ssl <- read_csv("data/SSLpupcounts.csv") -->
<!-- ssl -->
<!-- ssl_long <- ssl %>%  -->
<!--   pivot_longer(names_to = "year", -->
<!--                values_to = "count", -->
<!--                -sitename) %>%  -->
<!--   na.omit() -->
<!-- ssl_long -->

<!-- ssl_models <- ssl_long %>%  -->
<!--   group_by(sitename) %>%  -->
<!--   filter(count > 0, -->
<!--          year >= 2000) %>%  -->
<!--   mutate(year2 = as.numeric(year)-2000, -->
<!--          log_count = log(count)) %>%  -->
<!--   nest() %>%  -->
<!-- #str(ssl_models$data[1]) -->
<!--   mutate(model = map(data, ~lm(log_count ~ year2, data = .))) %>%  -->
<!--   mutate(coef = map(model, coef), -->
<!--          slope = map_dbl(coef, pluck, 2)) %>% -->
<!--   I() -->
<!-- ssl_models %>%  -->
<!--   ggplot() + -->
<!--   aes(x = fct_reorder(sitename, slope), y = slope) + -->
<!--   geom_point() + -->
<!--   coord_flip() + -->
<!--   NULL -->

<!-- ``` -->

<!-- ```{r} -->
<!-- system.time({ -->
<!-- nboot <- 100 -->
<!-- ssl_boot <- ssl_models %>% -->
<!--   mutate(tbl = map(model, augment)) %>%  -->
<!-- #bob <- ssl_boot %>%  -->
<!--   mutate(boot = map(tbl, specify, response = .resid)) %>%  -->
<!--   mutate(samples = map(boot, generate, reps = nboot, type = "bootstrap")) %>%  -->
<!--   mutate(nd2 = map(tbl, ~map_dfr(.x = seq_len(nboot),function(x) I(.))), -->
<!--          nd2 = map(nd2, select,-.resid), -->
<!--          nd2 = map2(nd2, samples, bind_cols), -->
<!--          nd2 = map(nd2, mutate, log_count = .fitted + .resid), -->
<!--          nd3 = map(nd2, function(x) {group_by(x, replicate) %>% nest()})) %>%  -->
<!--   mutate(bootmod = map(nd3, ~mutate(., slope = map_dbl(data, ~coef(lm(log_count~year2, data = .))[2]))), -->
<!--          quantboot = map(bootmod, ~quantile(.$slope, probs=c(0.025,0.5,0.975)))) %>% -->
<!--   unnest(quantboot) %>%  -->
<!--   mutate(quant = c("lower","med","upper")) %>%  -->
<!--   pivot_wider(names_from = quant, -->
<!--               values_from = quantboot) %>%  -->
<!--   I() -->

<!-- p1 <- ggplot(ssl_boot) + -->
<!--   aes(x = fct_reorder(sitename, med), y = med) + -->
<!--   geom_point() + -->
<!--   geom_errorbar(aes(ymin=lower, ymax=upper), width= 0.2) + -->
<!--   coord_flip() + -->
<!--   theme_minimal() + -->
<!--   labs(y = "slope", -->
<!--        x = "") + -->
<!--   NULL}) -->
<!-- p1 -->
<!-- ``` -->



---

## Problem 3  

We are interested in creating a standardized time series of CPUE for a fishery, by 'removing' the effect of variables that affect catch rates such that we have an index of abundance.  

We have many possible variables.  

We would like to compare models that use different combinations of these variables.  

<!-- --- -->

<!-- ```{r} -->

<!-- bsb <- read_csv("data/neus_bts.csv") %>%  -->
<!--   filter(comname == "BLACK SEA BASS", -->
<!--          biomass > 0, -->
<!--          season == "SPRING") -->
<!-- bsb -->

<!-- terms <- rev(names(bsb)[c(5:8)]) -->
<!-- parts <- str_c("s(",terms,")") -->
<!-- forms <- map(accumulate(parts, paste, sep = " + ", .init = "log(biomass) ~ factor(year)"), as.formula) -->

<!-- bsb_gams <- enframe(forms, name = "id", value = "formula") %>% -->
<!--   mutate(model = modelr::fit_with(bsb, mgcv::gam, .formulas = forms), -->
<!--          aic = map_dbl(model, AIC), -->
<!--          p1 = map(model, gratia::draw)) -->
<!-- bsb_gams2 <- bsb_gams %>%  -->
<!--   slice(which.min(bsb_gams$aic)) %>%  -->
<!--   #mutate(p1 = map(model, gratia::draw)) %>%  -->
<!--   #print(p1) %>%  -->
<!--   I() -->
<!-- print(bsb_gams2$p1) -->
<!-- ``` -->


## Problem 4

Status for endangered species are often based on a risk evaluation of population projections.  

We want to project population dynamics forward in time given uncertainty in future dynamics.  

We want to do this lots of times to quantify the risk of extinction.  


<!-- ```{r} -->
<!-- nsim <- 10 -->
<!-- nyr <- 100 -->
<!-- sd_proc <- 0.1 -->
<!-- errors <- map(seq_len(nsim), ~rnorm(nyr,0,sd_proc)) -->
<!-- pop_update <- function(N, proc_err, lambda = 1.05) lambda*N*exp(proc_err) -->
<!-- h <- rep(10,10) -->
<!-- initN <- 7500 -->
<!-- pop2 <- map(errors,~accumulate(., pop_update, .init = initN, lambda = 1.05)) -->
<!-- ``` -->

<!-- If there are 7,500 snow leopards in year 2018 and they are declining at 5% per year, in what year will they fall below 500 individuals? -->

<!-- ```{r prompt=TRUE,comment='',collapse=TRUE} -->
<!-- leopard.loop <- function(N, year=2018) { -->
<!--   while (N>=500) { -->
<!--     N <- N*0.95 -->
<!--     year <- year+1 -->
<!--   } -->
<!--   return(year) -->
<!-- } -->
<!-- leopard.loop(N=7500) -->
<!-- ``` -->

<!-- Pro-tip: when you end up in an infinite loop with no stopping point, press `<ESC>` to stop it running! -->




